# Names of the binaries to produce.
debug_target :=
release_target := release_$(debug_target)

# Type of the files to compile.
ft := cpp

src_dir := .
obj_dir := .
bin_dir := .

srcs := $(wildcard $(src_dir)/*.$(ft))
objs := $(patsubst $(src_dir)/%.$(ft), $(obj_dir)/%.o, $(srcs))

# Assert specific values for builtin variables.
CC := gcc
CFLAGS := -pedantic-errors -Wall -Wextra -Werror

CXX := g++
CXXFLAGS := -std=c++20 -pedantic-errors -Wall -Wextra -Werror

RM := rm -f

debug_flags := -O0 -g
release_flags := -O2 -DNDEBUG

# Use the correct compiler and compiler flags.
ifeq ($(ft), cpp)
compiler := $(CXX)
compiler_flags := $(CXXFLAGS)
else
compiler := $(CC)
compiler_flags := $(CFLAGS)
endif

# Determine appropriate recipes for targets "clean" and "fclean".
ifeq ($(bin_dir), .)
clean_recipe := $(RM) $(debug_target) $(release_target)
else
clean_recipe := $(RM) -r $(bin_dir)
endif

ifeq ($(obj_dir), .)
fclean_recipe := $(RM) $(notdir $(objs))
else
fclean_recipe := $(RM) -r $(obj_dir)
endif

# Makefile rules.
.PHONY: clean fclean debug release

debug: compiler_flags += $(debug_flags)
debug: $(bin_dir)/$(debug_target)

release: compiler_flags += $(release_flags)
release: fclean
release: $(bin_dir)/$(release_target)

clean:
	$(clean_recipe)

fclean: clean
	$(fclean_recipe)

# Avoid duplicate targets.
ifneq ($(obj_dir), $(bin_dir))
$(obj_dir):
	@mkdir $@
endif

$(bin_dir):
	@mkdir $@

$(obj_dir)/%.o: $(src_dir)/%.$(ft) | $(obj_dir)
	$(compiler) -c $(compiler_flags) -o $@ $<

$(bin_dir)/$(debug_target): $(objs) | $(bin_dir)
	$(compiler) -o $@ $^

$(bin_dir)/$(release_target): $(objs) | $(bin_dir)
	$(compiler) -o $@ $^
