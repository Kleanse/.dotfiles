*sum_usr_41.txt*	For Vim version 8.2	Last change: 2022 May 23

What I learned:

Vim script is the language used for the startup vimrc file, syntax files, and
many other things. It comes in two flavors: legacy and Vim9. The information
given here assumes Vim9.

Start scripting in Vim script with a simple example: >

	vim9script
	var i = 1
	while i < 5
	  echo "count is" i
	  i += 1
	endwhile

Write this text into a Vim script file (i.e., a file ending with ".vim") and
source it with ":source"; Vim will produce the following output:

	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~

The first line, "vim9script", tells Vim to process the script as a Vim9
script. The next line, "var i = 1", declares a variable named "i" and
initializes it with the value 1. The general form of a variable definition is >

	var {name} = {expression}

"while i < 5" defines a loop, which has the following form: >

	while {condition}
	  {statements}
	endwhile

The {statements} item executes while {condition} is true. In this example,
{condition} is the expression "i < 5", which is true when the variable "i" is
less than 5. Before this loop, "i" begins with 1, so "i < 5" is true and the
loop's statements execute. The first statement is the ":echo" command, which
prints its arguments, i.e., the string "count is" and the value of the
variable "i". In this initial loop iteration, the line

	count is 1 ~

is printed. The second statement increments "i" by one ("i += 1" is equivalent
to "i = i + 1"). Thus, "i" becomes 2 and is then used in {condition}, which
repeats the process.

The ":while" loop can be simplified using a ":for" loop: >

	for i in range(1, 4)
	  echo "count is" i
	endfor

Vim script recognizes numbers represented in four different formats: decimal,
hexadecimal, octal, and binary. Hexadecimal numbers begin with "0x" or "0X",
e.g., "0x1f", which is decimal 31. Octal numbers start with "0o" or "0O", and
binary numbers start with "0b" or "0B". Numbers without any prefix are treated
as decimal. (Note that in legacy script, a "0" before a decimal number tells
Vim to interpret the number as an octal number.)

":echo" always prints numbers in decimal: >

	echo 0x7f 0o36
<	127 30 ~

Make a number negative by preceding it with a minus sign ("-"): >

	echo -0x7f
<	-127 ~

A minus sign is also used for subtraction, which is sensitive to whitespace: >

	echo -0x7f -0o36
<	E1004: White space required before and after '-' at "-0o36" ~

(In legacy script, ":echo" sees the second "-" as subtraction, so the
expression is processed as if it was "-0x7f - 0o36".)

If two negative numbers was intended, surround the second expression in
parentheses: >

	echo -0x7f (-0o36)
<	-127 -30 ~


Like in C, a variable name in Vim script can only comprise ASCII letters,
digits, and underscores. It cannot begin with a digit.

Some variables are global; get a list of them with >

	:let

Global variables can be used anywhere, making them prone to naming collisions.
Thus, by default, variables defined inside a script are local to that script:
one script's "counter" variable is different from another's "counter".

To define a variable as global, precede it with "g:" and omit the ":var"
command: >

	vim9script
	g:counter = 5
	echo g:counter
<	5 ~

Find more information about script-local variables at |script-variable|.

The following table presents some of the kinds of variables available in Vim
script (see |internal-variables| for more information):

	b:name		variable local to a buffer
	w:name		variable local to a window
	g:name		global variable (also in a function)
	v:name		variable predefined by Vim

Delete a global variable to release memory with >

	:unlet g:counter

Append "!" to ignore the error message for a nonexistent variable.

Unlike global variables, script-local variables cannot be ":unlet" (in legacy
script, however, they can).

Script-local variables are not deleted even after their scripts finish. This
behavior exists so that functions defined inside the scripts can use them. (If
a script-local variable is suspected to be consuming a lot of memory, set it
to an empty value.)

Besides numbers, strings are supported in Vim script: >

	var name = "Peter"
	echo name
<	peter ~

Every variable has a type, which is usually determined by the value with which
the variable is initialized. This process is called type inference. If a
variable is defined without an initial value, its type must be specified: >

	var name: string
	var age: number
	...
	name = "Peter"
	age = 42

Assigning a value of the wrong type to a variable generates an error: >

	age = "Peter"
<	E1012: Type mismatch; expected number but got string ~

A string value (also called "string constant" or simply "string") is denoted
by either single or double quotes. A string with double quotes can include a
double quote by escaping it with a backslash "\": >

	var name = "he is \"Peter\""
	echo name
<	he is "Peter" ~

Single quotes avoid the need for this backslash: 'he is "Peter"'.

The difference between single-quote and double-quote strings is that all
characters inside a single-quote string are treated literally. Only the single
quote is special: type two to include one in the string. Conversely,
double-quote strings permit special characters. The following list presents
some of them:

	\t		<Tab>
	\n		<NL>, line break
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, backspace
	\"		"
	\\		\, backslash
	\<Esc>		<Esc>
	\<C-W>		CTRL-W

The last two are examples of the general "\<name>" form, where "name" is the
name of a special key.

See |expr-quote| for a full list of these special characters.


Visit |expression-syntax| for a summary of Vim script's expression syntax.

Numbers, strings, and variables are expressions themselves: they can be used
anywhere an expression is expected. Other items that are also expressions
include

	Syntax		Meaning ~
	$NAME		environment variable
	&name		option
	@r		register

One common use case of the &name form is to set an option's value, do
something, and then restore the option's original value.

Vim script supports the basic arithmetic operators:

	a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo

The standard precedence holds: >

	echo 10 + 5 * 2		echo (10 + 5) * 2
<	20			30 ~

The ".." operator is used to concatenate two strings: >

	echo "foo" .. "bar"
<	foobar ~

Vim script also has the conditional expression (borrowed from C): >

	a ? b : c

If expression "a" is true, expression "b" is used; otherwise, expression "c"
is used. All three expressions are evaluated before the conditional expression
itself is evaluated.


Vim script provides the ubiquitous "if" statement:

	if {condition}
	   {statements}
	endif

It works as usual: if {condition} is true, the {statements} are executed.
Almost as common as "if" is the optional "else" statement:

	if {condition}
	   {statements}
	else
	   {statements}
	endif

Its {statements} are executed when {condition} is false.

Vim script provides a third keyword--the "elseif"--for this sequence of
conditional branches:

	if {condition}
	   {statements}
	elseif {condition}
	   {statements}
	endif

It behaves like a pair of separate "else" and "if" statements, except it does
not necessitate an extra "endif".

Like the arithmetic operators, Vim script also supplies the standard logical
operators:

	a == b		equal to
	a != b		not equal to
	a >  b		greater than
	a >= b		greater than or equal to
	a <  b		less than
	a <= b		less than or equal to

Each operator returns true if its condition is met. For example, >

	if v:version >= 700
	  echo "congratulations"
	else
	  echo "you are using an old version, upgrade!"
	endif

The logical operators work on numbers and strings. For strings, the individual
byte values are compared, which might be wrong for some languages. Numbers and
strings cannot be compared with each other.

Strings have two further comparison operators:

	str =~ pat		matches with
	str !~ pat		does not match with

The left operand is used as a string, while the right operand is used as a
pattern. Thus, >

	if str =~ " "
	  echo "str contains a space"
	endif
	if str !~ '\.$'
	  echo "str does not end in a full stop"
	endif

Notice single quotes are used for the second pattern string. This kind of
string makes writing patterns convenient as backslashes need not be escaped
(as they would in a double-quote string).

The 'ignorecase' option is not considered when comparing strings. If ignoring
case is desired, use "==?". View the full list of logical operators at
|expr-==|.

Loops can use the two conventional statements that manipulate their execution:

	continue		Jump back to the start of the while loop; the
				loop continues.
	break			Jump forward to the "endwhile"; the loop is
				discontinued.


The ":execute" command is used to execute the result of an expression: >

	execute "tag " .. tag_name

Here, the string "tag " is concatenated with the value of the variable named
"tag_name", and the resulting string is executed as a command. If "tag_name"
has the value "get_cmd", the command executed is >

	tag get_cmd

":execute" only executes Ex commands. To execute Normal-mode commands, use
":normal": >

	normal gg=G

Unlike ":execute", ":normal" does not accept an expression as its argument but
rather literal command characters. In this case, the cursor is jumped to the
first line ("gg") and then all lines are formatted ("=G").

Combine ":normal" with ":execute" to make the former command work with an
expression: >

	execute "normal " .. count .. "j"

The argument to ":normal" must be a complete command. For example, the delete
operator must be followed by a movement command; a search command must end
with <CR>; Insert mode must be exited with <Esc>; and so forth. If the command
is incomplete, Vim will run into the end of the argument and abort.

Insert mode can be started in ":normal" and not be ended with <Esc>. In this
case, ":normal" inserts everything typed after the mode is entered and then
exits the mode automatically. Thus, the following command inserts "new text": >

	execute "normal inew text"

Of course, Insert mode must be exited explicitly if other commands need to be
performed after inserting text.

If only evaluating an expression to get its value is desired (and not
proceeding to execute it as an Ex command), use eval(): >

	var optname = "path"
	var optvalue = eval('&' .. optname)

The argument to eval() in this command is "&path". Since this expression is an
option variable, evaluating it yields the value of the correspondingly named
option. Therefore, eval("&path") returns the value of the 'path' option.


See |function-list| for the complete list of functions Vim script offers.

A function is called with the ":call" command, and arguments are given between
parentheses and separated by commas: >

	call search("Date: ", "W")

This command calls the search() function with the strings "Date: " and "W";
the former is used as a search pattern, and the latter is a set of flags--"W"
tells search() to not wrap around the end of the file.

Although unconventional, ":call" is mandatory when calling functions in legacy
script. In Vim9 script, however, it is optional. Thus, the following command
works the same: >

	search("Date: ", "W")

In both scripts, functions are called without ":call" when they are used in
expressions: >

	var line = getline(".")
	var repl = substitute(line, '\a', "*", "g")
	setline(".", repl)

Here, getline() fetches the line with the given line number from the current
buffer. The string "." refers to the cursor's line number. The second
function, substitute(), is similar to ":substitute". Its first parameter is
the string on which to perform the substitution; second parameter the pattern;
third the replacement string; and finally flags. The last function used is
setline(), which overwrites the line of the line number specified by the first
argument with a string given by the second argument.

For a list similar to |function-list| but ordered alphabetically, see
|builtin-function-list|.


Besides builtin functions, user-defined functions can be used. Their basic
definition is as follows: >

	def {name}({var1}, {var2}, ...): return-type
	  {body}
	enddef

(Note that {name} must begin with a capital letter [so that user-defined
functions can be differentiated from builtin ones].)

For example, the definition of a function that returns the smaller of two
numbers is >

	def Min(num1: number, num2: number): number
	  var smaller: number
	  if num1 < num2
	    smaller = num1
	  else
	    smaller = num2
	  endif
	  return smaller
	enddef

By default, variables without a prefix (such as "g:", "w:", or "s:") used
inside a function are local to that function. The ":return" statement returns
a value from a function.

With the conditional expression, Min() can be condensed into one statement: >

	def Min(num1: number, num2: number): number
	  return num1 < num2 ? num1 : num2
	enddef

User-defined functions are invoked the same way as builtin functions. Only
when these functions are called are mistakes such as syntax errors or
undefined variables or functions revealed. Get errors sooner by using >

	defcompile

in the script, which tells Vim to compile all functions defined in the script.

If a function returns nothing, omit the return type: >

	def SayIt(text: string)
	  echo text
	enddef

Functions can also be defined with the commands ":function" and
":endfunction", but then they are legacy functions: they use legacy syntax,
which does not enforce strong type checking, and are not compiled, making them
execute much slower.

A line range may be specified for a function call. Doing so calls the function
once for each line in the given range, positioning the cursor on the line
being processed. For example, the commands >

	def Number()
	  echo "line " .. line(".") .. " contains: " .. getline(".")
	enddef
	:10,15call Number()

call Number() six times: first on line 10 and last on line 15.

A function can take a variable number of arguments by having a List whose name
is prefixed with "..." as its last parameter: >

	def Show(start: string, ...items: list<string>)

Here, Show() is a function that requires 1 argument and can have up to 20
additional arguments. These arguments can be accessed through "items", which
is used like an ordinary List.

List all user-defined functions with >

	function
<	def <SNR>86_Show(start: string, ...items: list<string>) ~
	function GetVimIndent() ~
	function SetSyn(name) ~

The "<SNR>" prefix means the function is script-local. Vim9 functions begin
with "def", legacy functions "function". Specify the name of a function to see
its implementation: >

	function SetSyn
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~

To list functions matching a pattern, use ":filter": >

	filter Show function
<	def <SNR>86_Show(start: string, ...items: list<string>) ~
>
	function <SNR>86_Show
<	1    echohl Title ~
	2    echo "start is " .. start ~
	...

See |debug-scripts| for information about debugging Vim scripts. Set 'verbose'
to 12 or higher to see all functions calls, and 15 or higher to see every
executed line.

The command ":delfunction" can be used to delete functions defined in a legacy
script. Functions defined in a Vim9 script cannot be deleted.

Vim script supports function reference variables (abbreviated as "funcref"),
which are variables that can point to functions. For example, >

	def Right()
	  return 'Right!'
	enddef
	def Wrong()
	  return 'Wrong!'
	enddef

	var Afunc = g:result == 1 ? Right : Wrong
	Afunc()
<	Right! ~

assuming "g:result" is 1.

The stipulation for funcrefs, however, like user-defined functions, is that
their names must start with a capital.

See |user-functions| for more information about defining functions.


Vim supports two composite types: Lists and Dictionaries.

A List is an ordered sequence of items. Items are values that can be of any
type. Thus, a List of numbers, a List of Lists, and a List of mixed items are
possible. Define and initialize a List as follows: >

	var alist = ['aap', 'mies', 'noot']

This statement defines a List of three strings.

List items are enclosed in brackets and separated by commas. Omit all items to
create an empty List: >

	var alist = []

Items can be added to an existing List in three ways: with the "+" operator,
add(), or extend().

The "+" operator and extend() yield the same result, i.e., they extend a List.
They just have different syntax: >

	var alist = ['foo', 'bar']
	alist = alist + ['operator', '+']
	extend(alist, ['extend', 'function'])
	echo alist
<	['foo', 'bar', 'operator', '+', 'extend', 'function'] ~

Unlike these two methods, add() adds the given value as one item: >

	var alist = ['one']
	add(alist, ['two', 'three'])
	echo alist
<	['one', ['two', 'three']] ~

Lists can be iterated over with a ":for" loop: >

	var alist = ['one', 'two', 'three']
	for n in alist
	  echo n
	endfor
<	one ~
	two ~
	three ~

The general form of a ":for" loop is >

	for {varname} in {listexpression}
	  {commands}
	endfor

which evaluates as, "Loop over {listexpression}, assigning the next item to
{varname} per loop iteration."

A useful for-loop version is that in C, which loops a certain number of times.
Unlike C, Vim script does not provide a for loop that initializes and updates
a loop counter. However, it does provide range(), which can be used with the
":for" loop to achieve the same result: >

	for a in range(3)
	  echo a
	endfor
<	0 ~
	1 ~
	2 ~

See |range()| for more information about it, including setting different start
and end values and changing the stride's magnitude and direction.

Another example of the ":for" loop, which iterates over the first 20 lines of
the current buffer and echoes any date found: >

	for line in getline(1, 20)
	  if line =~ "Date: "
	    echo line
	  endif
	endfor

A Dictionary stores key-value pairs. Create one with braces: >

	var uk2nl = {one: 'een', two: 'twee', three: 'drie'}

Access a value by specifying the corresponding key in brackets: >

	echo uk2nl['two']
<	twee ~

Keys are strings and must be unique. They do not need to be defined with
quotes if they contain only alphanumeric characters, underscores, and dashes.
If a key comprises only word characters, the dot notation can be used: >

	echo uk2nl.two
<	twee ~

The general form of a Dictionary definition is >

	{<key>: <value>, ...}

An empty dictionary is one without any key-value pairs, i.e., only braces.

Dictionaries have many supplementary functions (see |dict-functions|). For
example, using keys() to iterate over a Dictionary's keys: >

	for key in keys(uk2nl)
	  echo key
	endfor
<	three ~
	one ~
	two ~

Keys are unordered. An order can be enforced with sort(): >

	for key in sort(keys(uk2nl))
	  echo key
	endfor
<	one ~
	three ~
	two ~


Vim script supports exceptions to handle runtime errors: >

	try
	   read ~/templates/pascal.tmpl
	catch /E484:/
	   echo "Sorry, the Pascal template file cannot be found."
	endtry

The ":read" command fails if the specified file does not exist. If it does
fail, this code catches the error and echoes a nice message to the user.

Errors generated between ":try" and ":endtry" are converted into exceptions.
An exception is a string containing an error number and message. Error numbers
are guaranteed to stay the same, regardless of the language locale.

If an exception is caught, execution proceeds as normal after ":endtry".
Otherwise, execution is aborted.

Catch all errors by omitting the pattern for ":catch": >

	try
	   read ~/templates/pascal.tmpl
	catch
	   echo "Sorry, the Pascal template file cannot be found."
	endtry

Unfortunately, this code is worse than not handling the errors at all because
it masks unrelated problems, such as "E21: Cannot make changes, 'modifiable'
is off."

The optional construct ":finally" may be specified within a ":try"-":endtry"
block. Success or fail, exception handled or uncaught, its statements will
always be executed. For example, >

	var tmp = tempname()
	try
	   exe ":.,$write " .. tmp
	   exe "!filter " .. tmp
	   :.,$delete
	   exe ":$read " .. tmp
	finally
	   call delete(tmp)
	endtry

This code filters the lines from the cursor until the end of the file through
the "filter" command, which takes a file name argument. Regardless if the
filtering works, something goes wrong between ":try" and ":finally", or the
user cancels the filtering by pressing CTRL-C, ":call delete(tmp)" is always
executed.

See |exception-handling| for more information about exceptions.


The end-of-line character depends on the system running Vim. For Vim scripts,
using the UNIX file format is recommended because it works on every system
(see |:source_crnl|). Thus, set 'fileformat' to "unix" before writing the
current file: >

	:setlocal fileformat=unix

In Vim script, blank lines and leading whitespace characters are ignored.
Trailing whitespace is also ignored but not always, e.g., ":map".

Include a whitespace character in the value of an option by escaping it with a
backslash "\": >

	:set tags=my\ nice\ file

In contrast to legacy script, Vim9 script is pedantic about whitespace: it
enforces a rigid style to improve readability and reduce mistakes.

Comments in Vim9 script begin with a "#". (In legacy script, a " is used to
start a comment.) All characters after and including this character until the
end-of-line are ignored. A comment may start at any place on a line but not
within an expression, such as a string.

Some commands, however, consider a comment to be part of its arguments. For
example, >

	abbrev dev development	# shorthand
	map <F3> o#include	# insert include
	execute cmd		# do it
	!ls *.c			# list C files

Here, the abbreviation "dev" expands to "development  # shorthand"; <F3>
starts a line and inserts the contents after "o"; ":execute" generates an
error; and "!" sends all subsequent characters to the shell. Therefore,
":map", ":abbreviate", and ":execute" (along with other commands) cannot share
the same line with a comment. However, these three commands may use a trick
with "|" to bypass this limitation:

	abbrev dev development|# shorthand
	map <F3> o#include|# insert include
	execute '!ls *.c'	|# do it

The "|" character separates two commands. In these cases, the second command
is only a comment, and the last command is a general solution to any command
that does not accept a comment or "|".

For ":map" and ":abbreviate", no whitespace appears before "|" because these
commands include all characters after them until the end-of-line or "|".
(Likewise, be careful of trailing whitespace with ":unmap".)

On UNIX systems, a special comment may be used to make a Vim script
executable: >

	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit

Sometimes, it is desirable to restore the cursor's original position and
window's view (i.e., the same line is at the top of the window) after making a
change. One example of achieving this goal is as follows: >

	map ,p ma"aYHmbgg"aP`bzt`a
<	ma			set mark a at cursor position
	  "aY			yank current line into register a
	     Hmb		go to top line in window and set mark b there
		gg		go to first line in file
		  "aP		put the yanked line above it
		     `b		go back to top line in display
		       zt	position the text in the window as before
			 `a	go back to saved cursor position

Generally, global functions and variables should be avoided to minimize
interference between plugins. However, one acceptable use of global variables
is when specifying preferences for plugins. For example, assuming the "mytags"
plugin exists, the following settings could be defined: >

	g:mytags_location = '$HOME/project'
	g:mytags_style = 'fast'

Vim9 introduces two new commands ":import" and ":export" to help make plugins
more modular. See |:export| for the details.


A Vim script other people can use is called a plugin. Installing a plugin is
as simple as moving it into the right directory (see |add-plugin|).

Vim script recognizes two types of plugins:

	1. Global plugins: for all types of files.
	2. Filetype plugins: only for files of a specific type.

Global plugins will be discussed first.

A plugin needs a name. This name should convey the plugin's features and not
be confused with a plugin that has the same name but provides different
capabilities. The subsequent examples assume a plugin named
"typecorrect.vim"--used for correcting typing mistakes--exists.

To ensure a plugin works for everyone, it must follow a set of guidelines,
which are explained one at a time.

Every plugin needs to have a body, which are the lines that do the actual
work: >

 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization

(The left-hand column shows line numbers, which are not actually part of the
lines and are only used to aid explanations.)

By default, all Vim scripts use legacy script. Most of the syntax described
earlier pertains to Vim9 script, and Vim9 script is recommended over legacy
script. Therefore, new plugins should begin with the line >

  1	vim9script noclear

which tells Vim to interpret all the commands in the script as Vim9 commands.
The "noclear" argument tells Vim not to delete the items defined inside the
script when the script is reloaded (relevant when using ":finish"). (See
|vim9-reload| for more information.)

Near the top, plugins should include a header containing a brief description
of the plugin, when the script was last changed, and the script's maintainer's
contact information: >

  2	# Vim global plugin for correcting typing mistakes
  3	# Last Change:	2021 Dec 30
  4	# Maintainer:	Bram Moolenaar <Bram@vim.org>

A short note about the plugin's license is also helpful: >

  5	# License:	This file is placed in the public domain.

Earlier, line 18 showed how to continue lines in Vim script
|line-continuation|. This mechanism, however, only works if 'compatible' is
unset. If 'compatible' is set, it cannot simply be reset because it has many
side effects. Instead, the proper solution is to set 'cpoptions' to its Vim
default and restore its original value later: >

 11	var save_cpo = &cpo
 12	set cpo&vim
 ..
 42	&cpo = save_cpo

Fortunately, this process is performed automatically in Vim9 scripts, except
for the vimrc file sourced when Vim starts.

The user needs a way to disable a plugin without removing it from
'runtimepath'. Additionally, a plugin should have a way to exit immediately if
it is loaded more than once. The following lines achieve these goals: >

  7	if exists("g:loaded_typecorrect")
  8	  finish
  9	endif
 10	g:loaded_typecorrect = 1

The name for checking whether a plugin is loaded is recommended to begin with
"g:loaded_" followed by the plugin's file name. The "g:" prefix makes the
variable global, which allows the user to disable the plugin in his vimrc
file.

Mappings in plugins should be defined so that they begin with the user's
preferred prefix key. Such a key can be referenced with <Leader>: >

 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;

The user can redefine the <Leader> key with "g:mapleader": >

	g:mapleader = "_"

In this case, the mapping defines the key sequence "_a". By default, <Leader>
is a backslash.

The <unique> argument is specified for ":map" so that an error message is
issued if a mapping for the given key sequence already exists.

Although this mapping practice is more flexible than one that locks the user
to a fixed sequence of keys, it still does not allow the user to change the
keys after <Leader>. To provide this capability, the mapping should be wrapped
with an ":if" statement that checks if a mapping to the <Plug> mapping exists: >

 21	if !hasmapto('<Plug>TypecorrAdd;')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;
 23	endif

This code only executes the ":map" command if no mappings map to
"<Plug>TypecorrAdd;". Therefore, the user a chance to define his own
left-hand-side key sequence for "<Plug>TypecorrAdd;": >

	map ,c  <Plug>TypecorrAdd;

To prevent a plugin's functions and variables from interfering with such items
of another plugin, they should be defined local to the script. Items in Vim9
script are script local by default. In legacy script, their names must be
prepended with "s:". Thus, the following function >

 30	def Add(from: string, correct: bool)
 31	  var to = input("type the correction for " .. from .. ": ")
 32	  exe ":iabbrev " .. from .. " " .. to
 ..
 36	enddef

is different from the Add() functions in other scripts. To refer to
script-local items in a mapping or menu entry, prepend their names with <SID>: >

 24	noremap <unique> <script> <Plug>TypecorrAdd;  <SID>Add
 ..
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 ..
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), true)<CR>

Each time the user types "\a" (assuming <Leader> is unset), the following
sequence executes: >

	\a  ->  <Plug>TypecorrAdd;  ->  <SID>Add  ->  :call <SID>Add(...)<CR>

The <SID> item simply gets the current script's ID and is translated when the
":map" or ":menu" command is executed.

Notice that ":noremap" is used on line 28 so that further mappings are not
inspected in the mapping's right-hand side. Lines 24 and 26 also use
":noremap" or similar, but they supply the <script> argument, which allows a
sequence of characters beginning with <SID> to be remapped. That is,
script-local items may be remapped. (See |:map-<script>| and |:menu-<script>|.)

Both <SID> and <Plug> effectively define different layers of mappings, ones
that do not collide with those beginning with a typed key |using-<Plug>|. This
behavior prevents <SID> and <Plug> mappings from being executed directly; they
must be mapped to by other mappings to be used. The following summarizes what
<SID> and <Plug> are and their purposes:

<Plug>	a special code that no typed key can produce. It is used to define an
	interface mapping: a mapping that hides its implementation details and
	enables the user to define a custom key sequence for it.
	    To limit naming collisions, <Plug> mappings should use the
	following naming format:
		<Plug> scriptname mapname
	For example, the example script in the current context has the name
	"Typecorr" and the mapname "Add". Thus, "<Plug>TypecorrAdd;" is used.
	A semicolon is used as a terminator so that "<Plug>TypecorrAdd" is not
	a substring of a longer <Plug> mapping, e.g.,
	"<Plug>TypecorrAddMarker".

<SID>	the script ID, i.e., a unique identifier for a script.
	    Internally Vim translates <SID> to "<SNR>123_", where "123" can be
	any number. Thus, a function "<SID>Add()" will have the name
	"<SNR>11_Add()" in one script and "<SNR>22_Add()" in another.

Commands in plugins should be defined in the following manner: >

 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call Add(<q-args>, false)
 40	endif

That is, define the command if no command with the same name already exists.
Using ":command!" is discouraged because it messes with the user's existing
commands. See where a command was last set by starting ":command" with
":verbose": >

	verbose command Correct

Script variables (and more generally items) are only visible in the script in
which they are defined. Their lifetimes are tied to that of Vim. (See
|s:var|.) Variables in Vim9 script are script local by default.

The following code is the complete version of "typecorrect.vim": >

  1	vim9script noclear
  2	# Vim global plugin for correcting typing mistakes
  3	# Last Change:	2021 Dec 30
  4	# Maintainer:	Bram Moolenaar <Bram@vim.org>
  5	# License:	This file is placed in the public domain.
  6
  7	if exists("g:loaded_typecorrect")
  8	  finish
  9	endif
 10	g:loaded_typecorrect = 1
 11	var save_cpo = &cpo
 12	set cpo&vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	var count = 4
 20
 21	if !hasmapto('<Plug>TypecorrAdd;')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd;
 23	endif
 24	noremap <unique> <script> <Plug>TypecorrAdd;  <SID>Add
 25
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), true)<CR>
 29
 30	def Add(from: string, correct: bool)
 31	  var to = input("type the correction for " .. from .. ": ")
 32	  exe ":iabbrev " .. from .. " " .. to
 33	  if correct | exe "normal viws\<C-R>\" \b\e" | endif
 34	  count += 1
 35	  echo "you now have " .. count .. " corrections"
 36	enddef
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  call Add(<q-args>, false)
 40	endif
 41
 42	&cpo = save_cpo

A plugin should provide documentation, known as help files, so that the user
knows its intended use, may better understand the plugin's functionalities,
can reference any minutia of the plugin, and determine whether a specific
behavior is a bug. Consult |add-local-help| for installing help files.

An example help file called "typecorrect.txt" for "typecorrect.vim" is as
follows: >

  1	*typecorrect.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd;
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorrect-settings*
 17	This plugin doesn't have any settings.

Only the format of first line matters: Vim displays it under the "LOCAL
ADDITIONS:" section of "help.txt" |local-additions|. For the details on
formatting help files, see |help-writing|.

When writing help files, be sure not to place existing tags inside **. This
guideline can be enforced by prepending tags with the name of the plugin, such
as "typecorrect-settings".

References to tags should be placed in ||, which makes them immediately
apparent.

If a file's type cannot be detected by Vim, set it with an autocommand: >

	au BufNewFile,BufRead *.foo		setlocal filetype=foofoo

Write this line into a script named "ftdetect/foofoo.vim" in the first
directory listed in 'runtimepath'. For example, on UNIX, the script's full
path is "~/.vim/ftdetect/foofoo.vim". By convention, the script's name is the
name of the filetype. See |new-filetype| for more information about adding a
filetype.

The following summarizes the special notation used for writing a plugin:

var name		Variable local to the script.

<SID>			Script-ID, used for mappings and functions local to
			the script.

hasmapto()		Function to test if the user already defined a mapping
			for functionality the script offers.

<Leader>		Value of "mapleader", which the user defines as the
			keys that plugin mappings start with.

map <unique>		Give a warning if a mapping already exists.

noremap <script>	Use only mappings local to the script, not global
			mappings.

exists(":Cmd")		Check if a user command already exists.


A filetype plugin is like a global plugin, except it sets options and defines
mappings for the current buffer only.  See |add-filetype-plugin| for
installing such a plugin.

Everything mentioned above about global plugins is relevant to filetype
plugins. So, read that part first. This part gives guidelines unique to
filetype plugins; the underlying principle is that a filetype plugin should
only influence the current buffer.

Users need a way to disable loading a filetype plugin. Such a capability can
be implemented by inserting the following code at the top of the plugin: >

	# Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	b:did_ftplugin = 1

(Note that a filetype plugin can be disabled only if its directory appears
before $VIMRUNTIME in 'runtimepath'.)

This code is similar to that of global plugins, except the variable is local
to the current buffer and its name is independent of the filetype plugin's
name. Also, like the code for global plugins, this code prevents the plugin
from being loaded more than once.

To override a setting of a distributed, default filetype plugin--say,
"vim.vim"--set the setting with the desired value in a script >

	setlocal textwidth=70

and write this script in the "after" directory, which causes it to be sourced
after the distributed "vim.vim" filetype plugin (see |after-directory|). For
example, on UNIX, the script's path would be "~/.vim/after/ftplugin/vim.vim".
(Note that the default plugin sets "b:did_ftplugin". Therefore, the variable
is not checked in this script so that it may execute.)

Only buffer-local options should be set in filetype plugins. If an option is
both global and local to a buffer, use >

	:setlocal

to set its buffer-local value (see |global-local|). For list options, use "+="
and "-=" to adjust their existing values.

When defining mappings in filetype plugins, specify the <buffer> argument to
constrain the mappings to the current buffer only: >

	if !hasmapto('<Plug>JavaImport;')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport;
	endif
	noremap <buffer> <unique> <Plug>JavaImport; oimport ""<Left><Esc>

Furthermore, all ":map" commands should be wrapped by a conditional statement
that allows the user to disable the mappings of a specific filetype plugin or
all filetype plugins: >

	# Add mappings, unless the user didn't want this.
	if !exists("g:no_plugin_maps") && !exists("g:no_mail_maps")
	  # Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote;')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote;
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote;
	  endif
	  vnoremap <buffer> <Plug>MailQuote; :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote; :.,$s/^/> /<CR>
	endif

The purposes of the two global variables are as follows:
|g:no_plugin_maps|	disables mappings for all filetype plugins
|g:no_mail_maps|	disables mappings for the "mail" filetype

Like mappings, commands should be defined with the "-buffer" argument so that
they are effective only for the current buffer: >

	command -buffer  Make  make %:r.s

Use the "b:" prefix to make variables local to the current buffer |b:var|.

Functions only need to be defined once. When the scripts they are defined in
are sourced a second time, they are defined again. Filetype plugins, unlike
global plugins, will naturally be sourced multiple times--specifically, every
time a file with their filetypes is opened. To avoid unnecessary redefinitions
of functions in such plugins, define each function as follows: >

	if !exists("*Func")
	  def Func(arg)
	    ...
	  enddef
	endif

All side effects a filetype plugin creates should be undone so that commands
such as ":setfiletype" work correctly. Specify the commands that undo these
side effects in the variable "b:undo_ftplugin": >

	let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ .. "| unlet b:match_ignorecase b:match_words b:match_skip"

Using ":setlocal" with "<" after the option name resets the option to its
global value. This is mostly the best way to reset an option.

For indent files, use "b:undo_indent" instead.

Both "b:undo_ftplugin" and "b:undo_indent" use legacy script syntax.

The filetype a filetype plugin affects must be specified in the plugin's file
name |ftplugin-name|. One of the three following formats may be used:

	ftplugin/stuff.vim
	ftplugin/stuff_foo.vim
	ftplugin/stuff/bar.vim

where "stuff" is the filetype and "foo" and "bar" are arbitrary names. (They
can be used to better describe the filetype plugin.)

The following summarizes the special notation used for writing a filetype
plugin:

<LocalLeader>		Value of "maplocalleader", which the user defines as
			the keys that filetype plugin mappings start with.

map <buffer>		Define a mapping local to the buffer.

noremap <script>	Only remap mappings defined in this script that start
			with <SID>.

setlocal		Set an option for the current buffer only.

command -buffer		Define a user command local to the buffer.

exists("*s:Func")	Check if a function was already defined.


A compiler plugin sets options for Vim when using a specific compiler; such a
plugin can be loaded with the |:compiler| command. Its main use is to set the
'errorformat' and 'makeprg' options. To see examples of a compiler plugin,
enter the command >

	args $VIMRUNTIME/compiler/*.vim

which edits all the default compiler plugins. Use ":next" to go to the next
plugin file.

These default compiler plugins have two special mechanisms. The first allows
the user to override the default file: >

	if exists("g:current_compiler")
	  finish
	endif
	g:current_compiler = "mine"

Setting "g:current_compiler" in a custom compiler plugin located in the first
directory of 'runtimepath' (e.g., ~/.vim/compiler for UNIX) causes the default
compiler plugin to terminate early.

The second mechanism uses ":set" for options when ":compiler!" is issued and
":setlocal" when ":compiler" is entered. Vim defines the ":CompilerSet"
command to support this mechanism. Older Vim versions, however, do not define
this command. In this case, the custom compiler plugin should define it. For
example, >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the default 'errorformat'
  CompilerSet makeprg=nmake

A compiler plugin created for the Vim distribution or a system-wide runtime
directory should include both of these mechanisms.

When writing compiler plugins that overrule or add to the settings of their
default compiler plugins, do not check "g:current_compiler". This omission,
like that for filetype plugins, allows them to be executed after the default
plugins. To be loaded last, they should should be placed in a directory at the
end of 'runtimepath', such as ~/.vim/after/compiler on UNIX.


Some plugins will be large. Loading them as normal--executing all their
commands when Vim starts--can incur a noticeable startup delay. To minimize
this delay, these plugins can be divided into two parts: one containing
commands that have a low impact on startup time, and the other comprising the
heavier commands. The former set of commands are loaded when Vim starts, and
the latter are executed only when they are used. This solution shifts the
delay from Vim's startup to the point the user uses these plugins'
functionalities.

The autoload feature in Vim facilitates implementing this solution: autoload
functions will not be defined until they are called.


A library script is a script containing functionalities used by other scripts.
It, like libraries for source code, makes scripts maintainable by grouping the
recycled commands into one location.

Library scripts may be loaded manually with one caveat: avoid loading them a
second time. This proviso can be satisfied with the |exists()| function: >

	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	MyLibFunction(arg)

Alternatively, library scripts may be loaded using Vim's autoload mechanism,
which is much simpler: >

	mylib#myfunction(arg)

Vim will recognize the function name after the embedded "#" character and when
it is not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
That script must define the "mylib#myfunction()" function.

With this method, make sure to prepend the names of functions in a library
script with the script's name followed by a "#"; otherwise, Vim will not know
which script to load.

The format of these autoload function names permit specifying subdirectories: >

	netlib#ftp#read('somefile')

In UNIX, the path of the corresponding script could be

	~/.vim/autoload/netlib/ftp.vim

Variables can also be used in this autoload mechanism: >

	var weekdays = dutch#weekdays

This command will load the script "autoload/dutch.vim".

For more information about the autoload system, see |autoload|.


Vim scripts intended for public use can be shared on two main websites: Vim's
website, http://www.vim.org, and GitHub. See |distribute-script| for other
resources about and suggestions for distributing Vim scripts.


 vim:tw=78:isk=!-~,^*,^\|,^\":ts=8:noet:ft=help:norl:
